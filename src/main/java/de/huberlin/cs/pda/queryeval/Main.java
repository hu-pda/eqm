package de.huberlin.cs.pda.queryeval;

import com.espertech.esper.client.deploy.DeploymentException;
import com.espertech.esper.client.deploy.ParseException;
import de.huberlin.cs.pda.queryeval.comparators.Comparator;
import de.huberlin.cs.pda.queryeval.comparators.LastEventComparator;
import de.huberlin.cs.pda.queryeval.comparators.FullComparator;
import de.huberlin.cs.pda.queryeval.esper.*;
import de.huberlin.cs.pda.queryeval.esper.event.Event;
import de.huberlin.cs.pda.queryeval.partitioning.Partitioner;
import de.huberlin.cs.pda.queryeval.plotting.Plotter;
import joptsimple.OptionException;
import joptsimple.OptionParser;
import joptsimple.OptionSet;
import joptsimple.OptionSpec;
import org.apache.commons.collections4.MapUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.IOException;
import java.io.PrintStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.text.SimpleDateFormat;
import java.util.*;


public class Main {
    private final static Logger logger = LoggerFactory.getLogger(Main.class);

    public static void main(String [] args) throws IOException, ParseException, DeploymentException, InterruptedException
    {
        OptionParser parser = new OptionParser();

        /**
         * Required options for both the partitioning mode and the evaluation mode.
         */
        OptionSpec<String> datasetOption
                = parser.accepts("dataset", "Choose a dataset  [dublin|google-cluster|debs2015|nasdaq] on which to run the queries.")
                .withRequiredArg()
                .required()
                .ofType(String.class);

        OptionSpec<File> datasetFolderOption
                = parser.accepts("dataset-folder", "The path to the folder of the dataset on which to evaluate the queries")
                .withRequiredArg()
                .required()
                .ofType(File.class);

        OptionSpec<File> saveDirOption
                = parser.accepts("save-dir", "Folder to save the traces, plots etc.")
                .withRequiredArg()
                .required()
                .ofType(File.class);

        OptionSpec<File> eplFileOption
                = parser.accepts("epl-file", "The .epl File containing the queries.")
                .withRequiredArg()
                .required()
                .ofType(File.class);

        OptionSpec<String> baseQueryOption
                = parser.accepts("base-query", "The name of the query in the .epl File that constitutes the ground truth for evaluation.")
                .withRequiredArg()
                .required()
                .ofType(String.class);

        /**
         * Options only for Partitioning
         */
        OptionSpec<Boolean> doPartitioningOption
                = parser.accepts("partitioning", "Execute partitioning into traces based on the base query for training of your algorithm.")
                .withOptionalArg()
                .ofType(Boolean.class)
                .defaultsTo(Boolean.FALSE);

        OptionSpec<Integer> partitioningWindowSize
                = parser.accepts("partitioning-window", "Partitioning creates traces by looking back a time window from when the base query is matched. Specify the size of the time window in Milliseconds. ")
                .requiredIf("partitioning")
                .withRequiredArg()
                .ofType(Integer.class);

        /**
         * Options only for Evaluation
         */
        OptionSpec<String> evaluatedGroupsOption
                = parser.accepts("evaluated-groups", "The comma-seperated names of the groups of queries in the .epl File that are to be evaluated.")
                .requiredUnless( "partitioning" )
                .withOptionalArg()
                .ofType(String.class);

        OptionSpec<String> evaluatedQueryOption
                = parser.accepts("evaluated-queries", "The comma-seperated names of the queries in the .epl File that are to be evaluated.")
                .requiredUnless("evaluated-groups")
                .requiredUnless( "partitioning" )
                .withRequiredArg()
                .ofType(String.class);

        OptionSpec<String> comparatorOption
                = parser.accepts("comparator", "Choose a comparator [full]. The chosen comparator determines when a match generated by the evaluated query counts as equal to a match of the base query. 'full' requires all events of a match to be the same. 'lastEvent' only requires the last events of two matches to be the same. New comparators are still to be implemented.")
                .withOptionalArg()
                .ofType(String.class)
                .defaultsTo("full");

        OptionSpec<File> plotDirOption
                = parser.accepts("plot-dir", "Folder where gnuplot scripts lie etc.")
                .requiredUnless( "partitioning" )
                .withRequiredArg()
                .ofType(File.class);

        OptionSpec<Void> help
                = parser.acceptsAll(Arrays.asList("h", "help", "?"), "Show help")
                .forHelp();

        try {
            OptionSet options = parser.parse(args);

            if (options.has(help)) {
                parser.printHelpOn(System.out);
                return;
            }

            String dataset = datasetOption.value(options);
            File datasetFolder = datasetFolderOption.value(options);
            File eplFile = eplFileOption.value(options);
            String baseQuery = baseQueryOption.value(options);
            Boolean doPartitioning = doPartitioningOption.value(options);

            String[] evaluatedQueries = {};
            if(options.has("evaluated-queries")){
                evaluatedQueries = evaluatedQueryOption.value(options).split(",", 0);
            }

            String[] evaluatedGroups = {};
            if(options.has("evaluated-groups")){
                evaluatedGroups = evaluatedGroupsOption.value(options).split(",", 0);
            }

            String comparatorString = comparatorOption.value(options);
            File saveDir = saveDirOption.value(options);
            File plotDir = plotDirOption.value(options);


            /***********************************************************************************
             *
             * 0. Partition DataSet-Files into Traces for Training your Algorithm
             *
             ***********************************************************************************/
            if(doPartitioning){

                saveDir.mkdirs();
                Integer windowSize = partitioningWindowSize.value(options);

                ProcessData dataBaseQueryProcessing;
                switch (dataset) {
                    case "dublin":
                        dataBaseQueryProcessing = new ProcessDublinData();
                        break;
                    case "google-cluster":
                        dataBaseQueryProcessing = new ProcessGoogleClusterData();
                        break;
                    case "debs2015":
                        dataBaseQueryProcessing = new ProcessDEBS2015Data();
                        break;
                    case "nasdaq":  // nasdaq
                        dataBaseQueryProcessing = new ProcessNasdaqData();
                        break;
                    default:
                        logger.error("Choose a dataset [dublin|google-cluster|debs2015|nasdaq]");
                        return;
                }
                long startingTime = 0L;
                Map<String, List<Map<String, Event>>> bQueryMatches = dataBaseQueryProcessing.run(datasetFolder, eplFile, startingTime, baseQuery, new String[]{}, new String[]{});
                dataBaseQueryProcessing.write(bQueryMatches, saveDir + ""); // write matches to file

                Partitioner.run(dataset, datasetFolder, baseQuery, windowSize, saveDir);

                System.exit(1);
            }


            /***********************************************************************************
             *
             * 0. General Preparation
             *
             ***********************************************************************************/

            /**
             * Create required folders for this program execution
             */
            Date now = new Date();
            SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd_hh:mm:ss");
            String time = dateFormat.format(now);
            String basePath = saveDir.getAbsolutePath() + "/" + time;
            boolean success = (new File(basePath + "/results/matches")).mkdirs();

            if (!success) {
                // Directory creation failed
                logger.error("Could not create a result folder.");
                return;
            }
            (new File(basePath + "/plots")).mkdirs();
            (new File(basePath + "/results/false-positives")).mkdirs();
            (new File(basePath + "/results/false-negatives")).mkdirs();
            (new File(basePath + "/results/perQuery")).mkdirs();
            (new File(basePath + "/results/perGroup")).mkdirs();
            (new File(basePath + "/results/perGroup")).mkdirs();


            /**
             * Create a file containing the config of this program exeuction
             */
            PrintStream configOut = new PrintStream(new File(basePath + "/config.dat"));
            MapUtils.verbosePrint(configOut, "options", options.asMap());


            /***********************************************************************************
             *
             * 1. General preparation
             *
             ***********************************************************************************/

            /**
             * Pick the comparator for the evaluation
             */
            Comparator comparator;
            switch (comparatorString) {
                case "full":
                    comparator = new FullComparator();
                    break;
                case "last-event":
                    comparator = new LastEventComparator();
                    break;
                default:
                    logger.error("Choose a dataset [full|last-event]");
                    return;
            }


            /***********************************************************************************
             *
             * 1. Generate query results using Esper
             *
             ***********************************************************************************/
            ProcessData dataProcessing;
            switch (dataset) {
                case "dublin":
                    dataProcessing = new ProcessDublinData();
                    break;
                case "google-cluster":
                    dataProcessing = new ProcessGoogleClusterData();
                    break;
                case "debs2015":
                    dataProcessing = new ProcessDEBS2015Data();
                    break;
                case "nasdaq":  // nasdaq
                    dataProcessing = new ProcessNasdaqData();
                    break;
                default:
                    logger.error("Choose a dataset [dublin|google-cluster|debs2015|nasdaq]");
                    return;
            }
            long startingTimeBase = 0L;
            Map<String, List<Map<String, Event>>> queryMatches = dataProcessing.run(datasetFolder, eplFile, startingTimeBase, baseQuery, evaluatedQueries, evaluatedGroups);
            dataProcessing.write(queryMatches, basePath + "/results/matches/"); // write matches to file


            List<Map<String, Event>> baseQueryMatches = queryMatches.get(baseQuery);
            queryMatches.remove(baseQuery);


            /***********************************************************************************
             *
             * 2. Compare query results with a given comparator
             *
             ***********************************************************************************/
            Evaluator eval = new Evaluator(baseQueryMatches, queryMatches, comparator);
            Map<String,EvalData> results = eval.evaluate();

            /***********************************************************************************
             *
             * 3. Write results to file and plot them
             *
             ***********************************************************************************/
            try {
                Path path = Paths.get(basePath + "/results/results.dat");
                String header = "Query\tTP\tFP\tFN\tPrecision\tRecall\tF1\n";
                Files.write(path, header.getBytes());

                for (Map.Entry<String, EvalData> queryEvaluation : results.entrySet()) {
                    logger.info("----------  " + queryEvaluation.getKey() + "  ------------");
                    logger.info(queryEvaluation.getValue().getResults());
                    logger.info("\n");


                    byte[] strToBytes = queryEvaluation.getValue().getResultsForFile().getBytes();
                    Files.write(path, strToBytes, StandardOpenOption.APPEND);

                    queryEvaluation.getValue().writeResultFiles(basePath + "/results/");
                }
            }catch(IOException e){
                logger.error(e.getMessage());
            }


            Plotter resultPlotter = new Plotter(plotDir, basePath, evaluatedQueries);
            resultPlotter.plot();

        }
        catch(OptionException e){
            parser.printHelpOn(System.out);
            logger.error(e.getMessage());
        }


    }
}
